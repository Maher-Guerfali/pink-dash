================================================================================
              TESTING GUIDE FOR TASKPINK APP - BEGINNER FRIENDLY
                      Learn Testing Step-By-Step
================================================================================

üéØ WHAT IS TESTING?
================================================================================

Simple Definition:
Testing = Writing code that checks if your app works correctly.

Real-Life Analogy:
- Without testing: You cook a meal and hope it tastes good.
- With testing: You taste the food while cooking to make sure it's good.

Testing in Code:
- You write small test programs that run your real code with test data.
- The test checks if the result matches what you expected.
- If it matches ‚Üí TEST PASSES ‚úÖ
- If it doesn't match ‚Üí TEST FAILS ‚ùå

Example:
Real code: getPatients(10) ‚Üí should return 10 patients
Test code: Call getPatients(10) ‚Üí check if result.length === 10


‚ùì WHY DO WE TEST?
================================================================================

1. CATCH BUGS EARLY
   - Without tests: Bug found by user 3 months later (embarrassing!)
   - With tests: Bug found immediately when you write the code

2. CONFIDENCE WHEN CHANGING CODE
   - Without tests: "If I change this, will it break something?"
   - With tests: Run tests ‚Üí see if anything broke

3. DOCUMENTATION
   - Tests show how code is supposed to work
   - New team member: "How does getPatients work?"
   - Look at tests ‚Üí see expected behavior

4. PREVENT REGRESSIONS
   - Regression = old bug comes back
   - Tests prevent this by catching it again


üìä TYPES OF TESTS (Don't Worry About All Of Them)
================================================================================

1. UNIT TESTS (What we're doing)
   - Test ONE function in isolation
   - Smallest, fastest tests
   - Example: Test PatientService.getPatients() alone
   - We'll focus on this

2. INTEGRATION TESTS (Advanced)
   - Test multiple parts working together
   - Example: PatientList component + PatientService + axios

3. END-TO-END (E2E) TESTS (Advanced)
   - Test whole app like a real user would
   - Example: "User searches for patient, clicks result, sees details"
   - Slower, more realistic

4. SNAPSHOT TESTS (Advanced)
   - Take "screenshot" of component output
   - Compare if it changed unexpectedly

FOR NOW: We'll do UNIT TESTS only.


üß™ THE TEST WE CREATED: STEP-BY-STEP BREAKDOWN
================================================================================

File: src/services/fhirService.test.ts

Let me explain each part:


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PART 1: IMPORTS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { describe, it, expect, beforeEach, vi } from 'vitest';

What each import does:

a) describe
   Purpose: Group related tests together
   Analogy: Like a folder for tests
   
   Code:
   describe('PatientService', () => {
     // All tests for PatientService go here
   });
   
   Output when you run:
   PatientService
     ‚úì returns only Patient resources

b) it
   Purpose: Define one test
   Analogy: One test case
   
   Code:
   it('returns only Patient resources from the bundle', async () => {
     // This is one test
   });
   
   Output:
   ‚úì returns only Patient resources from the bundle

c) expect
   Purpose: Check if something is true
   Analogy: Make an assertion
   
   Code:
   expect(result).toEqual([patient]);
   
   Meaning: "I expect result to equal [patient]"
   - If true ‚Üí test passes
   - If false ‚Üí test fails

d) beforeEach
   Purpose: Run code BEFORE each test
   Analogy: Setup before each test
   
   Code:
   beforeEach(() => {
     axiosGetMock.mockReset();
   });
   
   This runs before EVERY test to clean up

e) vi
   Purpose: Vitest utilities (mocking, spying)
   Mocking = Fake something for testing
   
   Code:
   const axiosGetMock = vi.fn();
   
   Meaning: Create a fake function we can control


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PART 2: MOCKING AXIOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

vi.mock('axios', () => {
  axiosGetMock = vi.fn();
  const create = vi.fn(() => ({ get: axiosGetMock }));
  return { default: { create }, __esModule: true };
});

WHY MOCK?
- PatientService uses axios to make REAL HTTP requests
- But we DON'T want to make real requests during tests
- Reasons:
  * Real requests are SLOW (network latency)
  * Tests need to be FAST
  * FHIR server might be down
  * We want to test with controlled data

WHAT'S HAPPENING?
1. vi.mock('axios') = "Replace the real axios with a fake one"
2. axiosGetMock = vi.fn() = "Create a fake get function"
3. when PatientService calls axios.create().get(), it calls our fake
4. We control what the fake returns (success or error)

SIMPLE ANALOGY:
Real: PatientService ‚Üí makes real HTTP request ‚Üí FHIR server
Fake: PatientService ‚Üí calls our fake ‚Üí we control response


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PART 3: BEFORE EACH TEST
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

beforeEach(() => {
  axiosGetMock.mockReset();
});

WHAT IT DOES:
- Before EACH test, clear the mock
- So previous test doesn't affect the next test

WHY?
Test 1: axiosGetMock returns patient data
Test 2: axiosGetMock returns error
If we don't reset, Test 2 might still have data from Test 1!

ANALOGY: Cleaning the workspace before each project


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PART 4: FIRST TEST - Filter Out Non-Patient Resources
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

it('returns only Patient resources from the bundle', async () => {
  // STEP 1: Create fake data
  const patient: Patient = {
    resourceType: 'Patient',
    id: '123',
    name: [{ given: ['Jane'], family: 'Doe' }],
  };

  const bundle: Bundle<Patient> = {
    resourceType: 'Bundle',
    type: 'searchset',
    entry: [
      { resource: patient },
      // Should be filtered out because not a Patient resource
      { resource: { resourceType: 'Observation', id: 'obs1' } as any },
    ],
  };

  // STEP 2: Tell mock what to return
  axiosGetMock.mockResolvedValue({ data: bundle });

  // STEP 3: Call the real function
  const result = await PatientService.getPatients(10);

  // STEP 4: Check if real function called mock correctly
  expect(axiosGetMock).toHaveBeenCalledWith('/Patient', { params: { _count: 10 } });

  // STEP 5: Check if result is correct
  expect(result).toEqual([patient]);
});

BREAKING IT DOWN:

Step 1: Create Test Data
  const patient = { ... };
  
  We create a fake patient object that looks like real data.
  TypeScript checks it matches Patient type.

Step 2: Mock Returns Data
  axiosGetMock.mockResolvedValue({ data: bundle });
  
  Meaning: "When axiosGetMock is called, make it return this bundle"
  - mockResolvedValue = mock returns a successful Promise
  - { data: bundle } = what the Promise resolves to
  
  So when PatientService calls:
  await fhirClient.get(...)
  
  It gets back:
  { data: bundle }

Step 3: Call Real Function
  const result = await PatientService.getPatients(10);
  
  This is the ACTUAL code we want to test!
  - It calls our mocked axios
  - It processes the bundle
  - It returns filtered patients

Step 4: Check the Mock Was Called Right
  expect(axiosGetMock).toHaveBeenCalledWith('/Patient', { params: { _count: 10 } });
  
  Meaning: "Make sure axiosGetMock was called with these exact arguments"
  - '/Patient' = the URL
  - { params: { _count: 10 } } = the options
  
  This tests that PatientService builds the request correctly

Step 5: Check the Result
  expect(result).toEqual([patient]);
  
  Meaning: "The result should be an array with just the patient"
  - NOT the Observation (got filtered out)
  - Just the Patient resource
  
  This tests that PatientService filters correctly


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PART 5: SECOND TEST - Empty Bundle
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

it('returns an empty array when bundle has no entries', async () => {
  const bundle: Bundle<Patient> = { resourceType: 'Bundle', type: 'searchset' };
  axiosGetMock.mockResolvedValue({ data: bundle });

  const result = await PatientService.getPatients();

  expect(result).toEqual([]);
});

WHAT IT TESTS:
- Edge case: server returns empty bundle
- Expected: function returns empty array

SAME STRUCTURE:
1. Create test data (empty bundle)
2. Mock to return it
3. Call real function
4. Check result is empty array

This tests error handling for when no patients exist.


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PART 6: THIRD TEST - Error Handling
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

it('propagates errors from getPatientById', async () => {
  axiosGetMock.mockRejectedValue(new Error('Network down'));

  await expect(PatientService.getPatientById('abc')).rejects.toThrow('Network down');
  expect(axiosGetMock).toHaveBeenCalledWith('/Patient/abc');
});

WHAT IT TESTS:
- When network fails, error is thrown
- Function was called with correct ID

KEY NEW CONCEPT:
mockRejectedValue = mock returns failed Promise
  
Instead of:
  axiosGetMock.mockResolvedValue({ data: bundle })

We use:
  axiosGetMock.mockRejectedValue(new Error('Network down'))

Meaning: "When axiosGetMock is called, make the Promise reject with this error"

CHECKING THE ERROR:
expect(PatientService.getPatientById('abc')).rejects.toThrow('Network down');

Meaning:
- Call getPatientById
- Expect it to throw/reject
- With error message 'Network down'

The .rejects keyword means "this Promise should be rejected"


üöÄ HOW TO RUN TESTS
================================================================================

STEP 1: Install dependencies
npm install

STEP 2: Run tests once
npm run test

Output:
‚úì fhirService.test.ts (3 tests)
  ‚úì returns only Patient resources from the bundle
  ‚úì returns an empty array when bundle has no entries
  ‚úì propagates errors from getPatientById

STEP 3: Run tests in watch mode (keeps running, re-runs on file change)
npm run test:watch

This is useful while developing:
- Change code ‚Üí test runs automatically
- See if you broke anything

STEP 4: Stop watch mode
Press Ctrl+C


üìù HOW TO WRITE YOUR OWN TESTS
================================================================================

TEMPLATE:

it('test description', async () => {
  // 1. SET UP TEST DATA
  const testData = { ... };
  
  // 2. MOCK THE DEPENDENCIES
  axiosGetMock.mockResolvedValue({ data: testData });
  
  // 3. CALL THE FUNCTION
  const result = await functionToTest(param);
  
  // 4. ASSERT EXPECTATIONS
  expect(result).toEqual(expectedValue);
  expect(somethingElse).toHaveBeenCalled();
});


EXAMPLE: Test for a new function

Say you add this to PatientService:

export const PatientService = {
  // ... existing functions ...
  
  searchPatientsByName: async (name: string): Promise<Patient[]> => {
    try {
      const response = await fhirClient.get<Bundle<Patient>>('/Patient', {
        params: {
          name: name
        }
      });
      
      if (!response.data.entry) {
        return [];
      }
      
      return response.data.entry
        .map(entry => entry.resource)
        .filter((resource): resource is Patient => resource.resourceType === 'Patient');
    } catch (error) {
      console.error(`Error searching patients with name ${name}:`, error);
      throw error;
    }
  }
};

Now write a test for it:

it('searches patients by name', async () => {
  // 1. SET UP
  const patient: Patient = {
    resourceType: 'Patient',
    id: '456',
    name: [{ given: ['John'], family: 'Smith' }],
  };
  
  const bundle: Bundle<Patient> = {
    resourceType: 'Bundle',
    type: 'searchset',
    entry: [{ resource: patient }],
  };
  
  // 2. MOCK
  axiosGetMock.mockResolvedValue({ data: bundle });
  
  // 3. CALL
  const result = await PatientService.searchPatientsByName('John');
  
  // 4. ASSERT
  expect(axiosGetMock).toHaveBeenCalledWith('/Patient', {
    params: { name: 'John' }
  });
  expect(result).toEqual([patient]);
});


üß© KEY TESTING CONCEPTS
================================================================================

1. MOCKING
   What: Replace real code with fake code
   Why: Control behavior, speed up tests
   Example: axiosGetMock instead of real axios

2. ASSERTIONS
   What: Checks that something is true
   Examples:
   expect(result).toEqual([patient])       // equal
   expect(result).toBeDefined()            // exists
   expect(result).toHaveLength(5)          // has 5 items
   expect(mockFn).toHaveBeenCalled()       // was called
   expect(mockFn).toHaveBeenCalledWith(...) // called with these args

3. ASYNC TESTING
   What: Testing code that uses async/await
   How: Use async/await in test
   Example:
   it('async test', async () => {
     const result = await someAsyncFunction();
   });

4. ERROR TESTING
   What: Make sure errors are handled correctly
   How: mockRejectedValue + .rejects.toThrow
   Example:
   expect(fn()).rejects.toThrow('error message');


‚úÖ TESTING CHECKLIST
================================================================================

When writing tests, ask yourself:

‚ñ° What is this function supposed to do?
‚ñ° What inputs should I test?
   - Normal case (happy path)
   - Edge case (empty, null)
   - Error case (something fails)
‚ñ° What are the dependencies? (Do I need to mock them?)
‚ñ° What should the output be?
‚ñ° How do I verify the output?


üîç COMMON TESTING PATTERNS
================================================================================

PATTERN 1: Test Happy Path (success case)
it('does what its supposed to do', async () => {
  // Normal data
  mockSuccess();
  const result = await fn();
  expect(result).toBeDefined();
});

PATTERN 2: Test Error Case
it('handles errors gracefully', async () => {
  mockError();
  expect(fn()).rejects.toThrow();
});

PATTERN 3: Test Edge Case (empty/null)
it('handles empty input', async () => {
  const result = await fn([]);  // empty array
  expect(result).toEqual([]);   // returns empty
});

PATTERN 4: Test Function Called Correctly
it('calls API with correct params', async () => {
  mockSuccess();
  await fn('param1');
  expect(axiosMock).toHaveBeenCalledWith('url', { params: { x: 'param1' } });
});


üìö LEARNING PATH FOR TESTING
================================================================================

BEGINNER (You are here):
‚úì What is testing?
‚úì Why test?
‚úì Unit tests with mocking
‚úì Running tests

INTERMEDIATE (Next):
- Testing React components (PatientList.tsx, PatientDetail.tsx)
- Testing hooks (useState, useEffect)
- Snapshot testing

ADVANCED:
- Integration tests
- E2E tests with Cypress
- Test coverage reports
- CI/CD (run tests automatically on each commit)


üéì REAL-WORLD TESTING WISDOM
================================================================================

1. WRITE TESTS AS YOU CODE
   Bad: Write all code, then write tests later (never happens!)
   Good: Write code + test together

2. TEST BEHAVIOR, NOT IMPLEMENTATION
   Bad: Test exact internal details
   Good: Test what user/caller sees

3. ONE ASSERTION PER TEST (Usually)
   Bad: Test 5 things in one test
   Good: Each test checks one thing

4. NAME TESTS CLEARLY
   Bad: it('works', ...)
   Good: it('returns empty array when no patients found', ...)

5. COVERAGE IS A TOOL, NOT A GOAL
   Bad: "We have 100% coverage"
   Good: "We test important behaviors"
   - Don't test every line; test behavior


üî• NEXT STEPS
================================================================================

1. UNDERSTAND THIS TEST
   - Read through fhirService.test.ts carefully
   - Run it: npm run test
   - See it pass ‚úÖ

2. RUN TEST IN WATCH MODE
   - npm run test:watch
   - Change test expectation on purpose
   - See it fail ‚ùå
   - Fix it to see it pass ‚úÖ

3. WRITE A SIMPLE TEST
   - Test a utility function
   - Follow the template above
   - Run it, see it pass

4. TEST YOUR OWN CODE
   - Add new functions to PatientService
   - Write tests for them
   - Run tests

5. ADVANCED: Component Testing
   - Test PatientList component
   - Test PatientDetail component
   - This is harder, ask for help!


================================================================================
                           YOU'VE GOT THIS! üéâ
                  Testing is a skill that makes you a better coder
================================================================================
